import {box, randomBytes, setPRNG} from 'tweetnacl';


//Source: https://github.com/dchest/tweetnacl-js/wiki/Examples
//Just added some more functions and changed the decode and encode functions with stablelib
//which is compatible with expo React Native
import {getRandomBytes} from 'expo-crypto';

import {decode as decodeUTF8, encode as encodeUTF8} from "@stablelib/utf8";
import {decode as decodeBase64, encode as encodeBase64} from "@stablelib/base64";

// tweetnacl requires PNRG to be set since we are not in a browser
//Very important to set the PRNG to a secure random number generator that has a good entropy
setPRNG((x, n) => {
    // copy n random bytes into x
    const randomBytes: Uint8Array = getRandomBytes(n);
    for (let i = 0; i < n; i++) {
        x[i] = randomBytes[i]
    }
});

const newNonce = () => randomBytes(box.nonceLength);
export const generateKeyPair = () => box.keyPair();

//This function is used to encrypt a message with a shared key
// The shared key is generated by the sender and receiver the algorithm used os also known as Diffie-Hellman key exchange
export const encrypt = (
    secretOrSharedKey: Uint8Array,
    json: any,
    key?: Uint8Array
): string => {
    const nonce = newNonce();
    const messageUint8: Uint8Array = encodeUTF8(JSON.stringify(json));
    const encrypted = key
        ? box(messageUint8, nonce, key, secretOrSharedKey)
        : box.after(messageUint8, nonce, secretOrSharedKey);

    const fullMessage = new Uint8Array(nonce.length + encrypted.length);
    fullMessage.set(nonce);
    fullMessage.set(encrypted, nonce.length);

    return encodeBase64(fullMessage);
};

export const decrypt = (
    secretOrSharedKey: Uint8Array,
    messageWithNonce: string,
    key?: Uint8Array
) => {
    const messageWithNonceAsUint8Array = decodeBase64(messageWithNonce);
    const nonce = messageWithNonceAsUint8Array.slice(0, box.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(
        box.nonceLength,
        messageWithNonce.length
    );

    const decrypted = key
        ? box.open(message, nonce, key, secretOrSharedKey)
        : box.open.after(message, nonce, secretOrSharedKey);

    if (!decrypted) {
        throw new Error('Could not decrypt message');
    }

    const base64DecryptedMessage = decodeUTF8(decrypted);
    return JSON.parse(base64DecryptedMessage);
};

//Function to Check if the provided private key is valid for the provided public key
export const checkPrivateKey = (publicKey: Uint8Array, privateKey: Uint8Array) => {
    console.log('Checking Private Key');
    try {
        const keyPair = box.keyPair.fromSecretKey(privateKey);
        return publicKey.toString() === keyPair.publicKey.toString();
    } catch (error) {
        console.log(error);
        return false;
    }
};
